Contributing to Sytopology
==========================

Sytopology follows the same pattern as
https://github.com/matrix-org/matrix-js-sdk/blob/master/CONTRIBUTING.rst.

Sytopology design
=================

Sytopology is a config generator for synapse. It gathers together the critical
descision points of a first time synapse install and provides a pretty ui to
walk new users through them. The result of using sytopology is a yaml file akin
to the sample config found in
`synapse's docs <https://github.com/matrix-org/synapse/tree/develop/docs>`_.
Through using sytopology the user also gains a knowledge of the environment in
which synapse will be running.

Sytopology can in theory run anywhere and the yaml file copied to the target
synapse, however, sytopology needs access to a local instance of synapse in
order to generate the sample configs.

The project is broken down into three parts. The api is stateless except for the
config directory which is passed to it at startup.


::

   +-----------+       +-----------+       +-------------+
   |           |       |           |       |             |
   |   webui   |<----->|    api    |<----->|   synapse   |
   |           |       |           |       |             |
   +-----------+       +-----------+       +-------------+


API
---

The api is a small server written using `klein <https://github.com/twisted/klein>`_. 

The api is hosted by default on localhost:16333. It serves the static files
generated by the compiled webui and handles a number of requests from the client.
Most of these requests are for analysing the environement of the synapse install
and include information such as the availabiliy of a port on the install's box and
the existance of files indicated by the user.

Once the step in the webui have been completed the ui sends a json with config options
to the api, which are translated a to a more representative format and passed to
synapse. This is through a post to the `/config` endpoint.

The structure of the api is as follows:

Api and model modules
~~~~~~~~~~~~~~~~~~~~~

The `api` module sets up the endpoints in klein and validates each request against
a json-schema.

The api module forwards requests to the `model` module which is a set of
utilities which interacts with the current state of the box. For example
model can check if the setup has been completed before, whether a config
exists, can write out the completed config and can creat secret keys for
the server.

sytopology script
~~~~~~~~~~~~~~~~~

The sytopology script configures and starts the server.


webui
-----

The webui is written in
`react-redux <https://redux.js.org/introduction/getting-started>`_. 

All state is kept within redux. The `js/reducers/state.js` file compiles an example
state which contains all the possible entries in the state. Note that this example
is not a valid state as it contains orthogonal settings.

There are two main sections in the state used:

- `baseConfig`: contains all the setting for the final synapse configuration.
- `setupUI`: contains the current state of the UI. Currently it contains the
  list of cards in the accordion which the user has entered settings into
  and can be toggled.

We use the reducer pattern. Actions triggered to manipulate state are in
`js/actions`. The triggered actions and current state are functionally
combined in `js/reducers` to produce a new state.

UI components are in `jsx` form under components. Their state is loaded from the
global state through their respective containers in `js/containers`.

Requests to the api are handled by `js/api`

Extending the accordion
~~~~~~~~~~~~~~~~~~~~~~~

The list of constants in `js/reducers/ui-constants.js` dictates the enumeration and
order of the cards in the accordion.

To extend the accordion with a new card create a component in `js/components`,
include a constant for it in `js/reducers/ui-constants` and a mapping from that
constant to the component in `js/components/UI.jsx`

Reseting state
~~~~~~~~~~~~~~

When an earlier card to the current state is toggled by a user the state is
reset to what it was before that earlier card was initially activated.

eg. given cards `A`, `B`, and `C`. Our user is currently filling in `C` having
completed `A` and `B`. Our user has a change of heart and returns to `B` to
change an option. The state is reset to only that which was set by `A`.

This is done by simply detailing every piece of state set by your card in 
`uiStateMapping` in `js/reducers/state.js`.

No two cards should manipulate the same state. So be careful when you are
invoking or creating actions and reducers.

